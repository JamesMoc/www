<div class="masthead">
    <div id="logoWrapper">
        <img src="/assets/logo-cropped.png" alt="rchain">
        <div class="textWrapper">
            <h1>RCHAIN</h1>
            <div>Scalable, Secure, Sustainable</div>
        </div>
    </div>
</div>

    <div class="bodyText">
        <div class="header">What is LADL?</div>
        <div class="body">LADL is a process to create spatial-behavioral type systems. Such a system not only describes the structure of datatypes, but also the behavior of the processes.</div>
        <div class="header">LADL and DAO</div>
        <div class="body">In 2016, the DAO lost $50M worth of ETH due to someone exploiting a race condition in a wallet contract. In a type system produced by LADL, one can declare that a contract should not contain a race. The compiler can check the code and guarantee that the contract is not susceptible to this kind of attack.</div>
        <div class="header">Logic As a Distributive Law</div>
        <div class="body">The implementation of a type in a programming language is describing a collection of values for that type. The class Natural, for instance, combines digits using juxtaposition. We can express types as "terms over collections". In many languages, we can, for instance, describe an employee class as follows:<br><br>
            <pre>{ "first": String, "last": String, "age": Natural, "salary": Natural }.</pre><br> 
            Compare this to an instance of the employee class: <br><br>
            <pre>{ "first": "Joe", "last": "Schmoe", "age": 35, "salary": 100000 }.</pre><br> 
            They're exactly the same, except that the class definition has types instead of values. Here's another example where the types are small enumerations:<br><br>
            <pre>Suit = [ "Club", "Diamond", "Heart", "Spade" ]<br>Value = [ "A", "2", "3", "4", "5", "6", "7", "8", "9", "J", "Q", "K" ]<br>Card = {"suit": Suit, "value": Value }</pre><br>
            If we think of the type Card as a collection, how many elements does it have? Well, there are four suits and thirteen values and 4 * 13 = 52, so fifty-two cards in all.<br> Now suppose we have a data structure that defines a term in a programming language, a syntax tree. We can describe collections of programs in exactly the same way: we simply replace parts of the program with collections that say what's allowed in that position. And just as we multiplied together the ways to make a suit with the ways to make a value in order to get a card, we'll be taking the product of all the collections that appear in the syntax tree. A contract in Rholang can describe the kind of sourcecode it's willing to run!<br> We can think of adding things to a collection as being analogous to adding numbers, while we can think of the term constructors in the language as being analogous to multiplication. Then just as we have a distributive law that takes products of sums to sums of products,<br><br>
            <pre>(a + b)(c + d) = ac + ad + bc + bd</pre><br>
            we have a way of turning an expression that involves terms with collections in them (like the class definitions above) into a collection of terms.<br> This is the core of the LADL algorithm, but there's more. The description of a programming language includes not only its grammar, but also the reduction rules. By allowing class definitions to talk about reduction rules as well as the structure of code, we can describe behaviors. Many security properties can be expressed in terms of behaviors, like "This code does not have a race condition", or "This name is never sent on a channel outside this namespace."<br> LADL can generate a spatial-behavioral type system for any programming language, but the formulae it generates are practically unusable by anything but formal verification systems unless the language has been designed with LADL in mind, like Rholang has.
        </div>
    </div>